## 7.类

#### 1.this

​	1.类内的成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象

​	2.因为this的目的总是指向类对象,所以this是一个常量指针,,我们不允许改变this中保存的地址

​	3.引入const成员函数

​		this仅仅是顶层const,所以不能把this绑定到一个常量对象上,这就使得我们不能再一个常量对象上调用普通的成员函数,因为this指针不能显式出现在参数列表中,在参数列表后加const表示this指针指向的是一个常量对象

​	4.常量对象,常量对象的引用或指针都只能调用常量成员函数 //因为普通this指针无法绑定常量对象

​	5.类作用域和成员函数

​		1.编译器分两步处理类,首先编译成员的声明,其次才轮到成员函数体,所以成员函数在类中定义的顺序可以随意

​		2.一般来说,如果非成员函数是类接口的组成部分,则这些函数的声明应该与类在同一个头文件内

#### 2.构造函数

​	1.构造函数不能被声明成const的,当我们创建类的一个const对象时,知道构造函数完成初始化过程,对象才能真正取得其“常量”属性,因此构造函数在const对象的构造过程中可以想起写值

​	2.如果没有类没有显示定义构造函数,则类会自己生成默认构造函数,但<如果定义在块中的内置类型和复合类型的对象被默认初始化,则它们的值是未定义的>,只有当类没有声明任何构造函数时,编译器才会自动生成默认构造函数

​	3.编译器不能为某些类合成默认的构造函数,例如,如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数,则编译器将无法初始化该成员

​	4.在构造函数参数列表的后面写上 = default来要求编译器生成默认构造函数

​	5.构造函数初始化列表

```
ListNode() : val(0), next(nullptr) {}
ListNode(int x) : val(x), next(nullptr) {}
ListNode(int x, ListNode *next) : val(x), next(next) {}
```

​	6.委托构造函数

​	7.隐式的类类型转换 //暂时不写

​		1.只允许一步类类型转换

​		2.类类型转化不是总有效 //暂不清楚

​		3.抑制构造函数定义的隐式转换	explicit

#### 3.拷贝,赋值和析构

#### 4.友元

​	1.类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数称为它的友元	friend + 函数声明即可

​	2.友元不是类的成员不受类所在区域访问控制级别的约束

​	3.一般来说,最好在类定义开始或结束前的位置集中声明友元

#### 5.其它

​	1.可变数据成员(mutable):可以在被const修饰的成员函数中依旧可以修改自身的值

​	2.基于const的重载,底层const的重载

​	3.类的静态成员

​		1.类的静态成员存在于任何对象之外,对象中不包含任何与静态数据成员有关的数据,静态成员函数不与任何对象绑定在一起,不包含this指针,不能声明为const的,静态成员需要在类外定义<因为静态成员需要在编译时期得到初始值,而类是在运行时才构造>

​		2. 类的静态成员被所在类的所有对象共享,可以使用类的对象，引用或者指针来访问静态成员

注意:

1.定义在类内部的函数是隐式的inline函数,当然编译器也会自己判定使用内联是否合适

2,class和struct定义类的区别,class默认private,struct默认public

3.封装的益处

​	1.取保用户代码不会无意间破坏封装对象的状态

​	2.被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码

4.在这项我困惑了一段时间,当我们提供一个类内初始值时,必须以符号=或者花括号表示

5.一个const成员函数如果以引用的形式返回*this,那么它的返回类型将是常量引用

6.如果一个构造函数为所有参数都提供了默认实参,则它实际上也定义了默认构造函数

7.字面值常量类 //暂不了解

