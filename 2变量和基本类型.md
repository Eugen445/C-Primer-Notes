## 变量和基本类型

#### 1 基本内置类型

###### 基本内置类型:

算数类型 <字符,整形,布尔值,浮点数>,  空类型(void)

###### char:

​	一个char的空间应确保可以存放机器基本字符集,一个char的大小和一个机器字节一样

###### 如何选择类型:

​	1.当明确数值不可能为负时,选用无符号类型

​	2.long一般和int大小相等,如果数值超过int,选用long long

​	3.执行浮点数运算选用double,float通常精度不够且双精度浮点数和单精度浮点数的计算代价相差不大,甚至在某些机器上面double更快,long double通常不使用,运行消耗大

#### 2 类型转换

###### 类型转换的情况

​	1.非布尔值的算数值赋给布尔类型时,值为0则结果为false,非0则结果为true

​	2.浮点数赋给整数类型只保留小数点之前的结果

​	3.如果赋给无符号类型一个溢出的值,例如unsigned char 赋予-1显示255,即(-1 + 256 ) % 256 = 255,(所赋予的值 + 数值总和) % 数值总和

​	4.带符号类型超出表示范围，结果未定义

#### 3 字面值常量

​	1.20 /十进制/	024 /八进制/	0x14 /十六进制/

​	2.”Hello World!”	//编译器会在字符串的结尾添加 ’\0’,因此字符字面值的实际长度需要 +1

​	3.仅由空格,缩进,换行符分割的字符串常量是一个整体

#### 4.初始化

​	1.double price = 109.99, discount = price * 0.16; //这是允许的

​	2.初始化不是赋值,初始化的含义是创建变量时赋予其一个初始值,而赋值的含义是把对象的当前值擦除,而以一个新值来替代

​	3.列表初始化

```
int a = 0;
int b = {0};
int c(0);
int d{0};
//如果用列表初始化初始值存在丢失信息的风险,则编译器将报错
int e{1.1}; C2397 从“double”转换到“int”需要收缩转换

```

​	4.默认初始化

​		定义于任何函数之外的变来那个称为全局变量:默认初始化整形为0,bool为false

#### 5.变量声明和定义的关系

​	1.变量能且只能被定义一次,但是可以被多次声明

```
extern int i;	//声明而非定义i
任何包含了显式初始化的声明即成为定义
在函数体内部初始化extern关键字标记的变量是错误的
extern int i = 10; //声明并定义
int j;			//声明并定义
```

​	2.复合类型

​		一条声明语句由一个基本数据类型和紧随其后的声明符列表

​		int *a = nullptr; *是声明符

​		int *a, b; //a是整形指针,b是整形变量

#### 6.引用

​	1.引用必须初始化,初始化后引用对象不可改变

​	2.引用并非对象,相反的,它只是为一个已经存在的对象所起的另外一个名字

​	3.引用本身不是一个对象,所以不能定义引用的引用

​	4.&是声明符 int &r = a, r2 = a; //r是a的引用,r2是整形变量

​	5.引用类型除了2种特殊情况必须与绑定对象严格匹配,引用只能绑定在对象上,而不能与字面值或某个表达式的计算结果绑定在一起

#### 7.指针

​	1.指针本身是一个对象,无需在定义时初始化,在生命周期内可以指向多个对象

​	2.因为引用不是对象,没有实际地址,所以不能定义指向引用的指针

​	3.指针类型必须与所指对象严格匹配

​	4.空指针不指向任何对象,生成空指针的方法

```
	int *p1 = nullptr;
	int *p2 = 0;
	int *p3 = NULL;
```

​	5.在使用指针之前必须初始化指针,如果使用了为初始化的指针,则该指针所占内存空间的当前内容被看作一个地址值.访问该指针,相当于去访问一个本不存在的位置上的本不存在的对象,如果指针所占内存空间恰好有内容,则会产生未知的情况

​	6.void* 指针: void * 是一种特殊的指针类型,可用于存放任意对象的地址,不能直接操作void * 指针所指的对象,可以用来和指针比较,作为函数的输入或输出或者赋给另外一个void * 指针.

​	7.指向指针的引用

​	引用本身不是一个对象,因此不能定义指向引用的指针,但指针是对象,所以存在对指针的引用

​	int *& r = p; //r是一个对指针p的引用

​	离变量名最近的符号对变量的类型有最直接的影响,因此r是一个引用

#### 8.const限定符

​	1.const对象值不可修改,必须初始化,初始化可以是任意复杂的表达式

​	2.const对象只能执行不改变其内容的操作

​	3.默认状态下,const对象仅在文件内有效	

```
	const int bufSize = 512;
	//编译器在编译过程中把用到该变量的地方都替换成对应的值,也就是说,
	//编译器会找到代码中所有用到bufSize的地方,然后用512替换为了执行上述替换
	//编译器必须知道变量的初始值,如果程序包含多个文件,
	//则每个用了const对象的文件都必须得能访问它的初始值,就必须在每一个
	//用到变量的文件中都有它的定义，为了支持这一用法，同时避免对同一变量的重复定义
	//默认情况下,const对象设定仅在文件内有效
```

​	4.如果想要在多个文件生效则必须在声明和定义前面都添加extern关键字,只需定义一次

​	5.const

​		1.可以把引用绑定到const对象上,称之为对常量的引用,对常量的引用不能被用作修改它所绑定的对象

​		2.

```
	const int ci = 1024;
	const int &r1 = ci; //正确,引用及其对象都是常量
	//int &r2 = ci;		//错误,试图让一个非常量引用指向一个常量对象
	int i = 42;
	const int &r2 = i;	//正确,允许将const int&绑定到一个普通int对象上
```

​		3.对const的引用可能引用一个非const对象	

```
int i = 42;
int &r1 = i;		//引用r1绑定对象i
const int &r2 = i;	//r2也绑定对象i,但是不允许通过r2修改i的值
r1 = 0;				//r1并非常量,i的值修改为0
r2 = 0;				//错误,r2是一个常量引用
//常量引用仅对引用可参与的操作做出了限定,对于引用的对象不做限定,对象是否可以改变取决于自己的类型
```

​		4.指针和const

​		指向常量的指针不能用于改变其所指对象的值,要想存放常量对象的地址,只能使用指向常量的指针

```
	const double pi = 3.14;
	//double *ptr = &pi;		//错误,ptr是一个普通指针
	const double *cptr = &pi;
	//*cptr = 42;				//错误,const限制的是*解引用的值,不可修改cptr指向的对象的值
	double p2 = 3.1415;
	cptr = &p2;					//const没有限制cptr不能修改指向的对象
```

​		5.const指针

```
	const double p1 = 3.14;
	const double *cptr = &p1;	//指向常量的指针 //指针指向的值不可修改(前提指向的值可以被修改),但指针的指向可以修改
	int errNumb = 0;
	int *const curErr = &errNumb; //常量指针	//指针指向的值可以修改(前提指向的值可以被修改),但指针的指向不可修改
```

​		6.顶层const

​		顶层const:指针本身是一个常量,也可以表示任意的对象是常量

​		底层const:指针所指的对象是一个常量	

```
	int i = 0;
	int *const p1 = &i;		//不能改变p1的值,这是一个顶层const
	const int ci = 42;		//不能改变ci的值,这是一个顶层const
	const int *p2 = &ci;	//允许改变p2的值,这是一个底层const
	const int *const p3 = p2;	//左是底层const,右是顶层const
	const int &r = ci;		//用于声明引用的const都是底层const
```

​		7.顶层const和底层const的拷贝操作

​		顶层const拷贝不受限制,底层const的拷入和拷出的对象必须具有相同的底层const资格,或者两个对象的数据类型必须能够转换,一般来说,非常量可以转换成常量

```
	int i = 0;
	int *const p1 = &i;		//不能改变p1的值,这是一个顶层const
	const int ci = 42;		//不能改变ci的值,这是一个顶层const
	const int *p2 = &ci;	//允许改变p2的值,这是一个底层const
	const int *const p3 = p2;	//左是底层const,右是顶层const
	const int &r = ci;		//用于声明引用的const都是底层const
	//int *p = p3;	//错误:p3包含底层const,而p没有
	p2 = p3;		//正确:p2和p3都是底层const
	p2 = &i;		//正确:int*能转换成const int*
	//int &r = ci;	//错误:普通的int&不能绑定到int常量上
	const int &r2 = i; //正确:const int&可以绑定到一个普通int上
	//p3即是顶层const也是底层const,但拷贝时不用关注顶层const
```

#### 9.constexpr和常量表达式

​	1.常量表达式:值不会改变并且在编译过程就能得到计算结果的表达式,字面值属于常量表达式,用常量表达式初始化的const对象也是常量表达式

```
//一个对象是不是常量表达式由它的数据类型和初始值共同决定
int get_size() 
{
	return 10;
}
void main() {
	const int max_files = 20;		//max_files是常量表达式
	const int limit = max_files + 1;//limit是常量表达式
	int staff_size = 27;			//staff_size不是常量表达式	//因为数据类型只是一个普通int
	const int sz = get_size();		//sz不是常量表达式			//尽管sz本身是一个常量,但它的具体指直到运行时才能获取到，所以也不是常量表达式
	}
```

​	2.constexpr变量

​	尽管定义一个const变量并把初始值设为我们认为的某个常量表达式,但可能因为疏忽产生了const int sz = get_size()这种因为是常量表达式,却实际不是的错误情形

​	C++11推出的constexpr类型可以由编译器来验证变量的值是否是一个常量表达式

```
int get_size() 
{
	return 10;
}
void main() {
	const int sz = get_size();		//sz不是常量表达式
	constexpr int sz2 = get_size(); //这是会在编译期间报错提醒,这不是一个常量表达式
}
//一般来说,如果你定义变量是一个常量表达式,那就把它声明成constexpr类型
//因为必须在编译时期就得到值,所以不能定义在函数体内,这是与预期不符的行为
```

​	3.指针和constexpr

​	如果指针被constexpr修饰,constexpr仅对指针生效,也就是说指针本身是一个常量指针(顶层指针)

```
	const int *p = nullptr;		//p是一个指向整形常量的指针
	constexpr int *q = nullptr;	//q是一个指向整数的常量指针
	int constexpr *q2 = nullptr;//q2是一个指向整数的常量指针
	int i = 42;
	constexpr const int *q3 = &i;	//q3是一个指向整形常量的常量指针
```

#### 10.处理类型

​	1.类型别名

​		1.typedef 

​		typedef double wages	//wages是double的别名

​		2.using

​		using ii = int					//ii是int的别名

​		p61指针,常量和类型别名

​	2.auto类型说明符

​		1.auto会自己推导最合适的类型

​		2.auto一般会忽略掉顶层const

​	3.decltype类型说明符	//暂时没写

​	4.自定义类型

​		