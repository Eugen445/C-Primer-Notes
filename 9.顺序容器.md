## 9.顺序容器

#### 1.容器

```
1.vector		<可变大小数组,支持快速随机访问,尾插快,在尾部之外的位置插入或删除元素可能很慢>
2.deque			<双端队列,支持快速随机访问,在头尾位置插入/删除速度很快>
3.list			<双向链表,只支持双向顺序访问,在list中任何位置进行插入/删除操作速度很快>
4.forward_list	<单向链表,只支持单向顺序访问,在链表任何位置进行插入/删除操作速度都很快>
5.array			<固定大小数组,支持快速随机访问,不能添加或删除元素>
6.string		<保存字符,随机访问快,尾插/尾删快>
//vector和string在中间位置每插入/删除一个元素需要移动插入/删除位置之后的所有元素，来保持连续存储，而且添加一个元素有可能还需要分配额外的存储空间(重新开辟一个更大的内存空间)
//list和forward_list访问元素的方法是遍历O(n),而且而外的内存开销很大
//除了forward_list没有外,其他容器的size是常量操作
```

#### 2.赋值运算和swap

![image-20210526204645251](C:\Users\梅露露\AppData\Roaming\Typora\typora-user-images\image-20210526204645251.png)

​	1.如果两个容器原来大小不同,赋值运算后两者的大小都与右边容器的原大小相同

​	2.swap通常比拷贝元素快

​	3.assign仅限于顺序容器

​	4.赋值相关运算会导致指向左边容器内部的迭代器,引用和指针失效,erswap不会(array,string除外)

#### 3.顺序容器操作

​	![image-20210526205748077](C:\Users\梅露露\AppData\Roaming\Typora\typora-user-images\image-20210526205748077.png)

​	1.向一个vector,string或deque插入元素会使所有指向容器的迭代器,引用和指针失效

​	2.当我们用一个对象来初始化容器时,或将一个对象插入到容器中时,实际上放入到容器中的是对象值的一个拷贝,而不是对象本身

​	3.在容器中的特定位置添加元素

​		1.每个insert函数都接受一个迭代器作为其第一个参数,因为迭代器可能指向容器尾部不存在的元素的位置,而且在容器开始位置插入元素是很有用的功能,所以insert函数将元素插入到迭代器所指定的位置之前

​		2.如果我们传递给insert一对迭代器,它们不能指向添加元素的目标容器

​	4.emplace操作

​		1.

注意:

​	1.选择容器的基本原则

```
//没必要背
1.vector是默认最好的选择
2.如果程序有很多小的元素,且空间的额外开销很重要,则不宜食用list或forward_list
3.如果程序要求随机访问元素,应使用vector或deque
4.如果程序要求在容器的中间插入或删除元素,应使用list或forward_list
5.如果程序要求在头尾插入或删除元素,但不会在中间位置进行插入或删除操作,则使用的却
*6.如果程序只有在读取输入时才需要在容器中间位置添加元素,当处理输入数据时,通常可以很容易地向vector追加数据,然后再调用标准库的sort函数来重排容器中的元素,从而避免在中间位置添加元素 <为何做这么麻烦的操作也不直接插入的原因是什么？>
如果必须在中间位置插入元素,考虑在输入阶段使用list,一旦输入完成,将list中的内容拷贝到一个vector中
```

​	2.假定noDefault是一个没有默认构造函数的类型

​	vector<noDefault> v1(10, init);	//正确,提供了元素初始化器

​	vector<noDefault> v1(10);			//错误,必须提供一个元素初始化器 //这种只适合有默认构造函数

​	只有顺序容器的构造参数才接受大小参数,关联容器并不支持

​	3.将一个容器初始化为另一个容器的拷贝

​		两种方法:1.直接拷贝整个容器,或者拷贝由一个迭代器对指定的元素范围

​		<为了创建一个容器为另一个容器的拷贝,两个容器的类型及其元素类型必须匹配,不过当传递迭代器参数来拷贝一个范围是,就不要求容器类型是相同的,而且新容器和原容器中的元素类型也可以不同,只要能将要拷贝的元素转换为要初始化的容器的元素类型即可>

​	4.关系运算符

​		每个容器类型都支持相等运算符(==和!=),除了无序关联容器之外的所有容器都支持关系运算符(>,>=,<,<=),关系运算符左右两边的运算对象必须是相同类型的容器且必须是相同类型的元素(已验证)

